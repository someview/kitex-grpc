package tpl

const ClientTpl = `// Code generated by Kitex. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"fmt"
	{{- if .HasStream}}
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	{{- end}}
	client "github.com/cloudwego/kitex/client"
	callopt "github.com/cloudwego/kitex/client/callopt"
	transport "github.com/cloudwego/kitex/transport"
)

{{range .ServiceList}}
{{- $serviceName :=.ServiceName }}

type {{$serviceName}}Client interface {
	{{- range .Methods}}
		{{- if or .ClientStreaming .ServerStreaming}}
	{{.Name}}(ctx context.Context {{if not .ClientStreaming}}, req *{{.RequestType}}{{end}}, callOptions ...callopt.Option) (stream {{$serviceName}}_{{.Name}}Client, err error)
		{{- else}}
	{{.Name}}(ctx context.Context, req *{{.RequestType}}, callOptions ...callopt.Option) (resp *{{.ReturnType}}, err error)
		{{- end}}
	{{- end}}
}

{{- range .Methods}}
{{- if or .ClientStreaming .ServerStreaming}}

type {{$serviceName}}_{{.Name}}Client interface {
	streaming.Stream
	{{- if .ClientStreaming}}
	Send(*{{.RequestType}}) error
	{{- end}}
	{{- if .ServerStreaming}}
	Recv() (*{{.ReturnType}}, error)
	{{- end}}
}  


// K{{$serviceName}}{{.Name}}Client is the client implementation for the stream method {{.Name}} of {{$serviceName}}.
type K{{$serviceName}}{{.Name}}Client struct {
	streaming.Stream
}


{{- if .ClientStreaming}}
func (c *K{{$serviceName}}{{.Name}}Client) Send(req *{{.RequestType}}) error {
	return c.Stream.SendMsg(req)
}
{{- end}}


{{- if .ServerStreaming}}
func (c *K{{$serviceName}}{{.Name}}Client) Recv() (*{{.ReturnType}}, error) {
	m := new({{.ReturnType}})
	return m, c.Stream.RecvMsg(m)
}
{{- end}}

{{- end}}
{{- end}}

// k{{$serviceName}}Client is an implementation of the {{$serviceName}}Client interface.
type K{{$serviceName}}Client struct {
	client.Client // The actual Kitex client
}

{{range .Methods}}

	{{- if or .ClientStreaming .ServerStreaming}}
func (c *K{{$serviceName}}Client) {{.Name}}(ctx context.Context {{if not .ClientStreaming}}, req *{{.RequestType}}{{end}}, callOptions ...callopt.Option) (stream {{$serviceName}}_{{.Name}}Client, err error) {
	streamClient, ok := c.Client.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err = streamClient.Stream(ctx, "{{.Name}}", nil, res)
	if err != nil {
		return nil, err
	}
	stream = &K{{$serviceName}}{{.Name}}Client{res.Stream}
	return stream, nil
}
	{{- else}}

func (c *K{{$serviceName}}Client) {{.Name}}(ctx context.Context, req *{{.RequestType}}, callOptions ...callopt.Option) (resp *{{.ReturnType}}, err error) {
	ctx = client.NewCtxWithCallOptions(ctx, callOptions)
	err = c.Client.Call(ctx, "{{.Name}}", req, resp)
	return
}

	{{- end}}
{{- end}}

// New{{$serviceName}}Client creates a client for the service defined in IDL.
func New{{$serviceName}}Client(destService string, opts ...client.Option) ({{$serviceName}}Client, error) {
	var options []client.Option
	options = append(options, client.WithDestService(destService))
	options = append(options, client.WithTransportProtocol(transport.GRPC))
	kc, err := client.NewClient(New{{$serviceName}}ServiceInfo(), options...)
	if err != nil {
		return nil, err
	}
	return &K{{$serviceName}}Client{
		Client: kc,
	}, nil
}
{{- end}}
`

// ... 其他代码 ...
